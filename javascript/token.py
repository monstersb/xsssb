class TokenType:
    addition = '+'
    addition_assignment = '+='
    ask = '?'
    assignment = '='
    colon = ':'
    comma = ','
    bitwise_and = '&'
    bitwise_and_assignment = '&='
    bitwise_or = '|'
    bitwise_or_assignment = '|='
    bitwise_not = '~'
    bitwise_not_assignment = '~='
    bitwise_xor = '^'
    bitwise_xor_assignment = '^='
    decrement = '--'
    division = '/'
    division_assignment = '/='
    dot = '.'
    equal = '=='
    empty = 'Empty'
    exponentiation = '**'
    exponentiation_assignment = '**='
    greater_than = '>'
    greater_than_or_equal = '>='
    increment = '++'
    invalid = 'Invalid'
    identifier = 'Identifier'
    keyword_await = 'Await'
    keyword_abstract = 'Abstract'
    keyword_break = 'Break'
    keyword_boolean = 'Boolean'
    keyword_byte = 'Byte'
    keyword_case = 'Case'
    keyword_catch = 'Catch'
    keyword_char = 'Char'
    keyword_class = 'Class'
    keyword_const = 'Const'
    keyword_continue = 'Continue'
    keyword_debugger = 'Debugger'
    keyword_default = 'Default'
    keyword_delete = 'Delete'
    keyword_do = 'Do'
    keyword_double = 'Double'
    keyword_else = 'Else'
    keyword_enum = 'Enum'
    keyword_export = 'Export'
    keyword_extends = 'Extends'
    keyword_final = 'Final'
    keyword_finally = 'Finally'
    keyword_float = 'Float'
    keyword_for = 'For'
    keyword_function = 'Function'
    keyword_goto = 'Goto'
    keyword_if = 'If'
    keyword_import = 'Import'
    keyword_implements = 'Implements'
    keyword_in = 'In'
    keyword_instanceof = 'Instanceof'
    keyword_int = 'Int'
    keyword_interface = 'Interface'
    keyword_let = 'Let'
    keyword_long = 'Long'
    keyword_native = 'Native'
    keyword_new = 'New'
    keyword_null = 'Null'
    keyword_of = 'Of'
    keyword_package = 'Package'
    keyword_private = 'Private'
    keyword_protected = 'Protected'
    keyword_public = 'Public'
    keyword_return = 'Return'
    keyword_short = 'Short'
    keyword_static = 'Static'
    keyword_super = 'Super'
    keyword_switch = 'Switch'
    keyword_synchronized = 'Synchronized'
    keyword_this = 'This'
    keyword_throw = 'Throw'
    keyword_throws = 'Throws'
    keyword_transient = 'Transient'
    keyword_try = 'Try'
    keyword_typeof = 'Typeof'
    keyword_var = 'Var'
    keyword_void = 'Void'
    keyword_volatile = 'Volatile'
    keyword_while = 'While'
    keyword_with = 'With'
    keyword_yield = 'Yield'
    left_brace = '{'
    left_bracket = '['
    left_parenthesis = '('
    left_shift = '<<'
    left_shift_assignment = '<<='
    less_than = '<'
    less_than_or_equal = '<='
    endl = 'End Line'
    logical_and = '&&'
    logical_or = '||'
    logical_not = 'not'
    multi_line_comment = 'Multi Line Comment'
    multiplication = '*'
    multiplication_assignment = '*='
    not_equal = '!='
    number = 'Number'
    remainder = '!'
    remainder_assignment = '!='
    regexp = 'Reg Expression'
    right_shift = '>>'
    right_shift_assignment = '>>='
    right_brace = '}'
    right_bracket = ']'
    right_parenthesis = ')'
    semicolon = ';'
    single_line_comment = 'Single Line Comment'
    space = 'Space'
    strict_equal = '==='
    strict_not_equal = '!=='
    string = 'String'
    subtraction = '-'
    subtraction_assignment = '-='
    terminator = 'Terminator'
    unsigned_right_shift = '>>>'
    unsigned_right_shift_assignment = '>>>='

    @staticmethod
    def is_terminal_symbolic(x):
        return x.startswith('_')

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return '[{0}] [{1}]'.format(self.type, self.value)

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return '[ {0:20s} ]       {1}'.format(self.type, repr(self.value))
