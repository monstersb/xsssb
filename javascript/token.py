class TokenType:
    addition = '_+'
    addition_assignment = '_+='
    ask = '_?'
    assignment = '_='
    colon = '_:'
    comma = '_,'
    bitwise_and = '_&'
    bitwise_and_assignment = '_&='
    bitwise_or = '_|'
    bitwise_or_assignment = '_|='
    bitwise_not = '_~'
    bitwise_not_assignment = '_~='
    bitwise_xor = '_^'
    bitwise_xor_assignment = '_^='
    decrement = '_--'
    division = '_/'
    division_assignment = '_/='
    dot = '_.'
    equal = '_=='
    empty = 'Empty'
    exponentiation = '_**'
    exponentiation_assignment = '_**='
    greater_than = '_>'
    greater_than_or_equal = '_>='
    increment = '_++'
    invalid = 'Invalid'
    identifier = '_identifier'
    keyword_await = '_await'
    keyword_abstract = '_abstract'
    keyword_break = '_break'
    keyword_boolean = '_boolean'
    keyword_byte = '_byte'
    keyword_case = '_case'
    keyword_catch = '_catch'
    keyword_char = '_char'
    keyword_class = '_class'
    keyword_const = '_const'
    keyword_continue = '_continue'
    keyword_debugger = '_debugger'
    keyword_default = '_default'
    keyword_delete = '_delete'
    keyword_do = '_do'
    keyword_double = '_double'
    keyword_else = '_else'
    keyword_enum = '_enum'
    keyword_export = '_export'
    keyword_extends = '_extends'
    keyword_final = '_final'
    keyword_finally = '_finally'
    keyword_float = '_float'
    keyword_for = '_for'
    keyword_function = '_function'
    keyword_goto = '_goto'
    keyword_if = '_if'
    keyword_import = '_import'
    keyword_implements = '_implements'
    keyword_in = '_in'
    keyword_instanceof = '_instanceof'
    keyword_int = '_int'
    keyword_interface = '_interface'
    keyword_let = '_let'
    keyword_long = '_long'
    keyword_native = '_native'
    keyword_new = '_new'
    keyword_null = '_null'
    keyword_of = '_of'
    keyword_package = '_package'
    keyword_private = '_private'
    keyword_protected = '_protected'
    keyword_public = '_public'
    keyword_return = '_return'
    keyword_short = '_short'
    keyword_static = '_static'
    keyword_super = '_super'
    keyword_switch = '_switch'
    keyword_synchronized = '_synchronized'
    keyword_this = '_this'
    keyword_throw = '_throw'
    keyword_throws = '_throws'
    keyword_transient = '_transient'
    keyword_try = '_try'
    keyword_typeof = '_typeof'
    keyword_var = '_var'
    keyword_void = '_void'
    keyword_volatile = 'volatile'
    keyword_while = '_while'
    keyword_with = '_with'
    keyword_yield = '_yield'
    left_brace = '_{'
    left_bracket = '_['
    left_parenthesis = '_('
    left_shift = '_<<'
    left_shift_assignment = '_<<='
    less_than = '_<'
    less_than_or_equal = '_<='
    endl = '_endl'
    logical_and = '_&&'
    logical_or = '_||'
    logical_not = '_not'
    multi_line_comment = '_multi_line_comment'
    multiplication = '_*'
    multiplication_assignment = '_*='
    not_equal = '_!='
    number = '_number'
    remainder = '_!'
    remainder_assignment = '_!='
    regexp = '_reg_expression'
    right_shift = '_>>'
    right_shift_assignment = '_>>='
    right_brace = '_}'
    right_bracket = '_]'
    right_parenthesis = '_)'
    semicolon = '_;'
    single_line_comment = '_single_line_comment'
    space = '_space'
    strict_equal = '_==='
    strict_not_equal = '_!=='
    string = '_string'
    subtraction = '_-'
    subtraction_assignment = '_-='
    terminator = 'Terminator'
    unsigned_right_shift = '_>>>'
    unsigned_right_shift_assignment = '_>>>='

    @staticmethod
    def is_terminal_symbolic(x):
        return x.startswith('_')

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return '[{0}] [{1}]'.format(self.type, self.value)

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return '[ {0:20s} ]       {1}'.format(self.type, repr(self.value))
